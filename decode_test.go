package godeckstring

import (
	"testing"
)

// TODO: A better way to share this information between tests.
// A deck with a mix of single and 2 copies.
var mixedDeckcode = "AAECAaoIBO/3AuGoA+O0A9PAAw2cArSRA7SXA8aZA7ulA8+lA9SlA9WlA/mlA7etA7mtA/6uA6qvAwA="
var mixedDeck = Deck{
	FormatType: FormatTypeStandard,
	Heroes: []Hero{
		Hero{
			DbfID: 1066, // Thrall
		},
	},
	Cards: []Card{
		Card{
			DbfID:  52148, // Mutate
			Copies: 2,
		},
		Card{
			DbfID:  54369, // Corrupt the Waters
			Copies: 1,
		},
		Card{
			DbfID:  52422, // Sludge Slurper
			Copies: 2,
		},
		Card{
			DbfID:  51380, // EVIL Cable Rat
			Copies: 2,
		},
		Card{
			DbfID:  54009, // EVIL Totem
			Copies: 2,
		},
		Card{
			DbfID:  284, // Novice Engineer
			Copies: 2,
		},
		Card{
			DbfID:  53947, // Questing Explorer
			Copies: 2,
		},
		Card{
			DbfID:  53967, // Sandstorm Elemental
			Copies: 2,
		},
		Card{
			DbfID:  53973, // Weaponized Wasp
			Copies: 2,
		},
		Card{
			DbfID:  55210, // Devoted Maniac
			Copies: 2,
		},
		Card{
			DbfID:  54969, // Corrupt Elementalist
			Copies: 2,
		},
		Card{
			DbfID:  54967, // Dragon's Pack
			Copies: 2,
		},
		Card{
			DbfID:  55166, // Shield of Galakrond
			Copies: 2,
		},
		Card{
			DbfID:  55907, // Kronx Dragonhoof
			Copies: 1,
		},
		Card{
			DbfID:  57427, // Galakrond, The Tempest
			Copies: 1,
		},
		Card{
			DbfID:  53972, // Mogu Fleshshaper
			Copies: 2,
		},
		Card{
			DbfID:  48111, // Shudderwock
			Copies: 1,
		},
	},
}

// A deck with only 2 copies.
var twoCopyDeckcode = "AAEBAf0EAA+sAbQEvAiMFI2sAoGyAuu6AoS7ApzTAu7TApbkArn/AsiHA82JA6aYAwA="
var twoCopyDeck = Deck{
	FormatType: FormatTypeWild,
	Heroes: []Hero{
		Hero{
			DbfID: 637, // Jaina Proudmoore
		},
	},
	Cards: []Card{
		Card{
			DbfID:  50120, // Elemental Evocation
			Copies: 2,
		},
		Card{
			DbfID:  38413, // Forbidden Flame
			Copies: 2,
		},
		Card{
			DbfID:  40324, // Freezing Potion
			Copies: 2,
		},
		Card{
			DbfID:  43420, // Shifting Scroll
			Copies: 2,
		},
		Card{
			DbfID:  45590, // Arcane Artificier
			Copies: 2,
		},
		Card{
			DbfID:  2572, // Arcane Blast
			Copies: 2,
		},
		Card{
			DbfID:  564, // Arcane Missiles
			Copies: 2,
		},
		Card{
			DbfID:  39169, // Babbling Book
			Copies: 2,
		},
		Card{
			DbfID:  43502, // Breath of Sindragosa
			Copies: 2,
		},
		Card{
			DbfID:  50381, // Daring Fire-eater
			Copies: 2,
		},
		Card{
			DbfID:  172, // Ice Lance
			Copies: 2,
		},
		Card{
			DbfID:  40299, // Kabal Lackey
			Copies: 2,
		},
		Card{
			DbfID:  1084, // Mirror Image
			Copies: 2,
		},
		Card{
			DbfID:  49081, // Shooting Star
			Copies: 2,
		},
		Card{
			DbfID:  52262, // Tome of Intellect
			Copies: 2,
		},
	},
}

// A test deck with several cards with more than 2 copies.
// Note: This deckcode generated by the decode function so a bit of a circular reference. Don't have a realistic example of this to validate implementation.
var nCopyDeckcode = "AAEAAf0EAAqsAbQEvAiMFIGyAuu6Au7TArn/As2JA6aYAwOEuwIDnNMCBMiHAwM="
var nCopyDeck = Deck{
	FormatType: FormatTypeUnknown,
	Heroes: []Hero{
		Hero{
			DbfID: 637, // Jaina Proudmoore
		},
	},
	Cards: []Card{
		Card{
			DbfID:  50120, // Elemental Evocation
			Copies: 3,
		},
		Card{
			DbfID:  40324, // Freezing Potion
			Copies: 3,
		},
		Card{
			DbfID:  43420, // Shifting Scroll
			Copies: 4,
		},
		Card{
			DbfID:  2572, // Arcane Blast
			Copies: 2,
		},
		Card{
			DbfID:  564, // Arcane Missiles
			Copies: 2,
		},
		Card{
			DbfID:  39169, // Babbling Book
			Copies: 2,
		},
		Card{
			DbfID:  43502, // Breath of Sindragosa
			Copies: 2,
		},
		Card{
			DbfID:  50381, // Daring Fire-eater
			Copies: 2,
		},
		Card{
			DbfID:  172, // Ice Lance
			Copies: 2,
		},
		Card{
			DbfID:  40299, // Kabal Lackey
			Copies: 2,
		},
		Card{
			DbfID:  1084, // Mirror Image
			Copies: 2,
		},
		Card{
			DbfID:  49081, // Shooting Star
			Copies: 2,
		},
		Card{
			DbfID:  52262, // Tome of Intellect
			Copies: 2,
		},
	},
}

// A singleton/highlander deck
var highlanderDeckcode = "AAECAR8eqAK1A+sHlwjFCNsJ3O4CnvACgPMCoIADm4UDoIUD5pYD+ZYDtpwDx50D/KMD5KQDpqUDhKcDiq0Djq0D+a4D/K8Dh7AD8LADgrEDkbED2LIDn7cDAAA="
var highlanderDeck = Deck{
	FormatType: FormatTypeStandard,
	Heroes: []Hero{
		Hero{
			DbfID: 31, // Rexxar
		},
	},
	Cards: []Card{
		Card{
			DbfID:  1047, // Tracking
			Copies: 1,
		},
		Card{
			DbfID:  49824, // Springpaw
			Copies: 1,
		},
		Card{
			DbfID:  55292, // Dwarven Sharpshooter
			Copies: 1,
		},
		Card{
			DbfID:  55161, // Blazing Battlemage
			Copies: 1,
		},
		Card{
			DbfID:  53756, // Zephrys the Great
			Copies: 1,
		},
		Card{
			DbfID:  52935, // Hench-Clan Hogsteed
			Copies: 1,
		},
		Card{
			DbfID:  54922, // Corrosive Breath
			Copies: 1,
		},
		Card{
			DbfID:  52790, // Ursatron
			Copies: 1,
		},
		Card{
			DbfID:  1243, // Unleash the Hounds
			Copies: 1,
		},
		Card{
			DbfID:  56223, // SN1P-SN4P
			Copies: 1,
		},
		Card{
			DbfID:  296, // Kill Command
			Copies: 1,
		},
		Card{
			DbfID:  54926, // Diving Gryphon
			Copies: 1,
		},
		Card{
			DbfID:  53860, // Desert Spear
			Copies: 1,
		},
		Card{
			DbfID:  1093, // Deadly Shot
			Copies: 1,
		},
		Card{
			DbfID:  437, // Animal Companion
			Copies: 1,
		},
		Card{
			DbfID:  46940, // Wing Blast
			Copies: 1,
		},
		Card{
			DbfID:  47134, // Sandbinder
			Copies: 1,
		},
		Card{
			DbfID:  52070, // Marked Shot
			Copies: 1,
		},
		Card{
			DbfID:  47488, // Houndmaster Shaw
			Copies: 1,
		},
		Card{
			DbfID:  1003, // Houndmaster
			Copies: 1,
		},
		Card{
			DbfID:  55408, // Dragonmaw Poacher
			Copies: 1,
		},
		Card{
			DbfID:  55303, // Dragonbane
			Copies: 1,
		},
		Card{
			DbfID:  49184, // Zilliax
			Copies: 1,
		},
		Card{
			DbfID:  55426, // Faceless Corruptor
			Copies: 1,
		},
		Card{
			DbfID:  55640, // Veranus
			Copies: 1,
		},
		Card{
			DbfID:  52089, // Unleash the Beast
			Copies: 1,
		},
		Card{
			DbfID:  54148, // Siamat
			Copies: 1,
		},
		Card{
			DbfID:  53926, // Dinotamer Brann
			Copies: 1,
		},
		Card{
			DbfID:  55441, // Dragonqueen Alexstrasza
			Copies: 1,
		},
		Card{
			DbfID:  49819, // Zul'jin
			Copies: 1,
		},
	},
}

// A deckstring from a tavern brawl with a single card.
var singleCardDeckcode = "AAECAaIHAdf6AgAA"
var singleCardDeck = Deck{
	FormatType: FormatTypeStandard,
	Heroes: []Hero{
		Hero{
			DbfID: 930, // Valeera Sanguinar
		},
	},
	Cards: []Card{
		Card{
			DbfID:  48471, // Pogo-Hopper
			Copies: 1,
		},
	},
}

func TestMixedDecode(t *testing.T) {
	decodedDeck, _ := Decode(mixedDeckcode)

	// Check the decoded deck matches expected resutls.
	checkDecks(decodedDeck, mixedDeck, t)
}

func TestTwoCopyDecode(t *testing.T) {
	decodedDeck, _ := Decode(twoCopyDeckcode)

	// Check the decoded deck matches expected results.
	checkDecks(decodedDeck, twoCopyDeck, t)
}

func TestHighlanderDecode(t *testing.T) {
	decodedDeck, _ := Decode(highlanderDeckcode)

	// Check the decoded deck matches expected results.
	checkDecks(decodedDeck, highlanderDeck, t)
}

func TestNCopyDecode(t *testing.T) {
	decodedDeck, _ := Decode(nCopyDeckcode)

	// Check the decoded deck matches expected results.
	checkDecks(decodedDeck, nCopyDeck, t)
}

func TestSingleCardDecode(t *testing.T) {
	decodedDeck, _ := Decode("AAECAaIHAdf6AgAA")

	// Check the decoded deck matches expected results.
	checkDecks(decodedDeck, singleCardDeck, t)
}

func checkDecks(actual Deck, expected Deck, t *testing.T) {
	// Deck type should match.
	if actual.FormatType != expected.FormatType {
		t.Errorf("expected format type '%d' got '%d'.", expected.FormatType, actual.FormatType)
	}

	// The heros should be in aggreement.
	if len(actual.Heroes) != len(expected.Heroes) {
		t.Errorf("Expected %d but got %d heroes.", len(expected.Heroes), len(actual.Heroes))
	}

	// There is typically a single hero in all practical examples.
	if actual.Heroes[0].DbfID != expected.Heroes[0].DbfID {
		t.Errorf("Expected hero DBF ID %d but got %d.", expected.Heroes[0].DbfID, actual.Heroes[0].DbfID)
	}

	// Ensure the length of decoded cards match expectations.
	if len(actual.Cards) != len(expected.Cards) {
		t.Errorf("Expected %d decoded cards but got %d cards.", len(expected.Cards), len(actual.Cards))
	}

	// Ensure all the cards in the actual set are in the expected one with the appropriate number of copies.
	for _, actualCard := range actual.Cards {
		hasMatch := false
		for _, expectedCard := range expected.Cards {
			if actualCard.DbfID == expectedCard.DbfID {
				hasMatch = true
				if actualCard.Copies != expectedCard.Copies {
					t.Errorf("Expected DBF ID %d to have %d copies but had %d instead.", actualCard.DbfID, expectedCard.Copies, actualCard.Copies)
				}

				continue
			}
		}

		if hasMatch != true {
			t.Errorf("The decoded card %d was not found in the expected cards list.", actualCard.DbfID)
		}
	}
}
